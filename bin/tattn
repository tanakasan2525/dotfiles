#!/usr/bin/env ruby
require 'optparse'
require "#{ENV['DOTPATH']}/lib/color"

def tattn
  puts %q{  _        _   _          }.red
  puts %q{ | |_ __ _| |_| |_ _ __   }.red
  puts %q{ | __/ _\` | __| __| '_ \ }.red
  puts %q{ | || (_| | |_| |_| | | | }.red
  puts %q{  \__\__,_|\__|\__|_| |_| }.red
end

def neko
  puts %q{          Zzzzz  |\      _,,,--,,_       }
  puts %q{                 /,\`.-'\`'   ._  \-;;,_ }
  puts %q{                |,4-  ) )_   .;.(  \`'-' }
  puts %q{@tattn         '---''(_/._)-'(_\_)       }
end

def trend
  require "#{ENV['DOTPATH']}/lib/trend"
end  

def ascii args
  require "#{ENV['DOTPATH']}/lib/ascii_art"
  ascii_art args
end

case ARGV[0]
when 'tattn'; tattn
when 'neko';  neko
when 'trend';  trend
when 'ascii'; ascii ARGV[1..-1]
else
end

options = {}

OptionParser.new do |opt|
  begin
    opt.version = '0.0.1'
    # opt.on('-u VAL', '--user', 'user') {|v| OPTS[:u] = v}
    # opt.on('-p VAL', '--password', 'password') {|v| OPTS[:p] = v}
    # opt.on('-s [VAL]', '--server', 'server name') {|v| OPTS[:s] = v}
    opt.on('--tattn', 'show tattn') {|v| options[:tattn] = v }
    opt.on('--neko', 'show neko') {|v| options[:neko] = v }
    opt.on('-h','--help','show this message') { puts opt; exit }

    opt.parse!(ARGV)
  rescue => e
    puts "ERROR: #{e}.\nSee #{opt}"
    exit
  end
end

if options[:tattn]
  tattn
elsif options[:neko]
  neko
elsif options[:u]
  artii ARGV[:u]
end

# tattn() {
#     usagi() {
#         echo '    /) /)'
#         echo '_(　_ ๑❛ᴗ❛)_ ＜ ﾆｬｰﾝ'
#     }
#
#     kuma() {
#         echo '(´(ｪ)`) ＜ ﾆｬｰﾝ'
#     }
#
#     github() {
#         echo '=͟͟͞͞=͟͟͞͞=͟͟͞͞　(\ (\'
#         echo '=͟͟͞͞=͟͟͞͞=͟͟͞͞(,, 0 ω 0) ＜ ﾆｬｰﾝ'
#         echo '=͟͟͞͞=͟͟͞͞=͟͟͞͞(/ (/ \) \)'
#     }
#
#
#     while [ $1 ]; do
#         case $1 in
#             -h|--help)
#                 help
#                 return
#                 ;;
#             *)
#                 modes=($modes[*] $1)
#                 ;;
#         esac
#         shift
#     done
#
#     if (( $#modes == 0 )); then
#         help
#         return
#     fi
#
#     for mode in $modes; do
#         if type $mode > /dev/null 2>&1; then
#             $mode
#         else
#             echo "No such mode \"$mode\""
#         fi
#     done
# }
#
#
# tattn $@
